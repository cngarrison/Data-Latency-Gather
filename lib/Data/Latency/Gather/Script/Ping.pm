package Data::Latency::Gather::Script::Ping;

use v5.16;
use Moo;
use Types::Standard qw(Bool ArrayRef Str Int);

extends 'Data::Latency::Gather::Script';

use Data::Latency::Gather;

use MooX::Options protect_argv => 0, 
				  description  => 'Gather latency data for host(s)', 
				  authors      => ['Charlie Garrison <garrison@zeta.org.au'],
				  synopsis => '
    ./bin/check-latency.pl print_data

    ./bin/check-latency.pl print_data -v

    ./bin/check-latency.pl --man
    
    docker-machine create --driver amazonec2 --amazonec2-region ap-southeast-2 aws-ddg
    eval $(docker-machine env aws-ddg)
    docker build -t data-latency-gather .
    docker run -it --rm --name check-latency data-latency-gather
' ;

use Data::Printer;
use Try::Tiny;
use LWP::UserAgent;
use JSON::MaybeXS;

# VERSION: generated by DZP::OurPkgVersion

has "_ua" => (
	is      => 'rw',
	isa     => sub {
	  die "$_[0] is not a LWP::UserAgent!" unless $_[0]->isa('LWP::UserAgent')
	},
	reader  => 'ua',
	lazy    => 1,
	clearer  => 'reset_ua',
	builder => '_build_ua',
);

sub _build_ua {
	my $ua = LWP::UserAgent->new( cookie_jar => {} );
	$ua->timeout(1200);    # 20 minutes, this could need to be even longer if queue gets big. But more sensible would be increase frequency of cron job
	return $ua;
}

has 'json' => (
	is      => 'rw',
	isa     => sub {
	  die "$_[0] is not a JSON::MaybeXS!" unless $_[0]->isa('JSON::MaybeXS') || $_[0]->isa('Cpanel::JSON::XS')
	},
	lazy    => 1,
	builder => '_build_json',
);

sub _build_json {
	my $self = shift;
	
	my $json = try {
		JSON->new->space_after->utf8(1);	# make compatible with postgres json stuff
	} catch {
		Data::Latency::Gather->logger->log(sprintf("error: failed to create json obj: %s", $_));
		return;
	};
	return $json;

} ## end sub _build_json

option 'host' => (
	is     => 'ro',
# 	isa    => ArrayRef[Str],
	isa    => ArrayRef,
	format => 's@',
# 	short   => 'h', ## conflcits with --help (-h)
	default => sub { [undef] }, # need at least one host to start loop - undef will use default host
	autosplit => ',', # --host=1,2,3
	documentation => qq{Host to ping},
	long_doc => qq{Host to ping - can be list of host names or IP addresses},
);


sub cmd_print_data {
	my $self = shift;

	$self->logger->info("\n---------------------\nPing Data\n---------------------");
	$self->logger->debug(np($self->host));
# 	print "PING $host $package_s(@{[$package_s+8]}) bytes of data\n";

	my $debug = Data::Latency::Gather->config->{debug};
	my $uri   = Data::Latency::Gather->config->{collector_url};
	
	my $results = {};
	foreach my $host (@{$self->host}) {
		my $data = Data::Latency::Gather->do_ping($host);

		my $tot_time = 0;
		my $avg_time = 0;
		my $ack_cnt = 0;
		my $nack_cnt = 0;
		my $server_ip = '';

		foreach my $l (@$data) {
			$self->logger->info(sprintf "%s from %s (%s): time=%f ms\n",
						  $l->{status}, $l->{host}, $l->{ip}, $l->{time} * 1000);
			$tot_time += $l->{time};
			if ($l->{status} eq 'OK') {
				$ack_cnt++;
			} else {
				$nack_cnt++;
			}
			$server_ip ||= $l->{ip};
		}
		$avg_time = $tot_time / $ack_cnt;
		$results = {
# 				tester_id        => $tester_id,
			server_requested => $host,
			server_contacted => $server_ip,
# 				(
# 					$params->{ping_timestamp}
# 					? ( ping_timestamp => DateTime::Format::HTTP->parse_datetime( $params->{ping_timestamp} ) )
# 					: ()
# 				),
			ping_count => scalar @$data,
			ping_nack  => $nack_cnt,
			ping_time  => $avg_time * 1000,
			raw        => $self->json->encode($data),
		};

	# 	my $auth_basic = sprintf( 'Basic %s', MIME::Base64::encode( sprintf( '%s:%s', $self->username, $self->api_key ), '' ) );
		my $resp_obj = {};
		my $resp = $self->ua->post(
			$uri,
	# 		Authorization => $auth_basic,
			Content       => $results
		);

		if ( $resp->code == 200 ) {
			try {
				say sprintf( "Sent results for %s", $results->{server_contacted} );
	# 			say sprintf( "Received JSON result: %s", p($resp_obj) );    # if $self->verbose;
			}
			catch {
				warn sprintf( "ERROR parsing response for %s - %s\n", $uri, $_ );
	# 			warn sprintf( "ERROR content: \n%s\n",                $resp->content );    # if $self->verbose;
			};
		} else {
			warn sprintf( "ERROR - Response Code %s for request %s\n%s\n", $resp->code, $uri, $resp->content );
		}


	}



	return;
} ## end sub cmd_print_results_data


1;



__END__

=encoding utf8

=head1 NAME

check-latency.pl - Gather latency data for host(s)

=head1 VERSION

Version 0.01

=head1 SYNOPSIS

    ./bin/check-latency.pl print_data

    ./bin/check-latency.pl print_data -v

    ./bin/check-latency.pl --man
    
    docker-machine create --driver amazonec2 --amazonec2-region ap-southeast-2 aws-ddg
    eval $(docker-machine env aws-ddg)
    docker build -t data-latency-gather .
    docker run -it --rm --name check-latency data-latency-gather


=head1 DESCRIPTION

Gather ping/latency statistics for supplied hosts. The script requires a
command in order to do anything useful. Look under FUNCTIONS for list of
available commands. Don't include `cmd_` when passing commands to the
script.

=head1 FUNCTIONS - SCRIPT COMMANDS

=head2 cmd_print_data

Run generic ping command.


=head1 AUTHOR

Charlie Garrison L<garrison@zeta.org.au>

=cut



